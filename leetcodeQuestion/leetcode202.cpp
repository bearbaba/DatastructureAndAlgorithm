/*
编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：

对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果 可以变为  1，那么这个数就是快乐数。
如果 n 是快乐数就返回 true ；不是，则返回 false 。

 

示例 1：

输入：19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1

#include<set>
#include<iostream>
using namespace std;
*/

class Solution {
public:
    bool isHappy(int n) {
        set<int> res;
        while(true){
            int sum=getSum(n);
            if(res.find(sum)==res.end()){
                res.insert(sum);
                n=sum;
            }else{
                break;
            }
        }
        return getSum(n)==1;
    }
private:
    int getSum(int n){
        int sum=0;
        int m;
        while(n>0){
            m=n%10;
            n=n/10;
            sum+=(m*m);
        }
        return sum;
    }
};

/*
题解：

当数的总和不为 1 时，情况有两种，一种是无限循环，另一种是无限不循环，

对于 3 位数的数字，它不可能大于 243。这意味着它要么被困在 243以下的循环内，要么跌到 1。4 位或 4 位以上的数字在每一步都会丢失一位，直到降到 3 位为止。所以我们知道，最坏的情况下，算法可能会在 243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 1。但它不会无限期地进行下去，所以我们排除无限不循环的可能。

如果是无限循环，那么这一题数就会产生环，解决环的最佳方法是使用集合，集合中存放的数字是唯一的，那么当这个数循环时，也就是进入到环中时，必然会出现数已经在集合中的情况， set.find(n) 就会找到这个数。
*/